协程（Coroutines）是计算机程序的一类组件，推广了协作式多任务的subroutine (子例程)，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活
## 有栈（stackful）协程和无栈（stackless）协程

有栈协程跟纤程、goroutines 基本是一个概念，由用户自行调度的、操作系统之外的运行单元。每个这样的运行单元都有自己独立的栈空间，缺点就是栈的空间占用和切换栈的开销。

而无栈协程没有独立的栈空间，每个协程只需要一个很小的栈帧，空间占用小，也没有栈的切换开销。

C++20 的协程是无栈的。部分原因是有栈的协程可以使用纯库方式实现，而无栈的协程需要一点编译器魔法帮忙。毕竟，协程里面的变量都是要放到堆上而不是栈上的。

一个简单的无栈协程调用的内存布局如下图所示：
![](../images/Pasted%20image%2020251208142509.png)可以看到，协程 C 本身的本地变量不占用栈，但当它调用其他函数时，它会使用线程原先的栈空间。在上面的函数 D 的执行过程中，协程是不可以挂起的——如果控制回到 B 继续，B 可能会使用目前已经被 D 使用的栈空间！

因此，无栈的协程牺牲了一定的灵活性，换来了空间的节省和性能。有栈的协程可能起几千个就占用不少内存空间，而无栈的协程可以轻轻松松起到亿级。

## C++20 协程
协程是一种可以暂停执行并在稍后恢复的函数。（cppreference 定义协程）

C++20 标准化的只是协程的底层语言支持。这些接口的目标用户实际上也不是普通开发者，而是库的作者。

协程可以有很多不同的用途，常见情况：

- 生成器    
- 异步 I/O
- 惰性求值
- 事件驱动应用

协程相关的新关键字：

- `co_await`
- `co_yield`
- `co_return`

一个协程里只能使用 co_return，不能使用 return。
### co_await、co_yield、co_return 和协程控制

```cpp
auto result = co_await 表达式;
```

编译器会把它理解为：

```cpp
auto&& __a = 表达式;
if (!__a.await_ready()) {
  __a.await_suspend(协程句柄);
  // 挂起/恢复点
}
auto result = __a.await_resume();
```

也就是说，“表达式”需要支持 `await_ready`、 `await_suspend` 和 `await_resume` 三个接口。如果 `await_ready()` 返回真，就代表不需要真正挂起，直接返回后面的结果；否则，执行 `await_suspend` 之后即挂起协程，等待协程被唤醒之后再返回 `await_resume()` 的结果。这样一个表达式被称作是个 awaitable。

标准里定义了两个 awaitable，如下所示：

```cpp
struct suspend_always {
  bool await_ready() const noexcept
  {
    return false;
  }
  void await_suspend(coroutine_handle<>) const noexcept {}
  void await_resume() const noexcept {}
};

struct suspend_never {
  bool await_ready() const noexcept
  {
    return true;
  }
  void await_suspend(coroutine_handle<>) const noexcept {}
  void await_resume() const noexcept {}
};
```

`suspend_always` 永远告诉调用者需要挂起，而 `suspend_never` 则永远告诉调用者不需要挂起。两者的 `await_suspend` 和 `await_resume` 都是平凡实现，不做任何实际的事情。一个 awaitable 可以自行实现这些接口，以定制挂起之前和恢复之后需要执行的操作。

`coroutine_handle` 是 C++ 标准库提供的类模板。这个类是用户代码跟系统协程调度真正交互的地方，有下面这些成员函数：

- `destroy`：销毁协程
- `done`：判断协程是否已经执行完成
- `resume`：让协程恢复执行
- `promise`：获得协程相关的 promise 对象（协程和调用者的主要交互对象；一般类型名称为 `promise_type`）
- `from_promise`（静态）：通过 promise 对象的引用来生成一个协程句柄

协程的执行过程大致是这个样子的：

1. 为协程调用分配一个协程帧，含协程调用的参数、变量、状态、promise 对象等所需的空间。
2. 调用 `promise.get_return_object()`，返回值会在协程第一次挂起时返回给协程的调用者。
3. 执行 `co_await promise.initial_suspsend()`；根据上面对 `co_await` 语义的描述，协程可能在此第一次挂起（但也可能此时不挂起，在后面的协程体执行过程中挂起）。
4. 执行协程体中的语句，中间可能有挂起和恢复；如果期间发生异常没有在协程体中处理，则调用 `promise.unhandled_exception()`。
5. 当协程执行到底，或者执行到 `co_return` 语句时，会根据是否有非 void 的返回值，调用 `promise.return_value(…)` 或 `promise.return_void()`，然后执行 `co_await promise.final_suspsend()`。

用代码可以大致表示如下：

```cpp
  frame = operator new(…);
  promise_type& promise = frame->promise;

  // 在初次挂起时返回给调用者
  auto return_value = promise.get_return_object();

  co_await promise.initial_suspsend();
  try {
    执行协程体;
    可能被 co_wait、co_yield 挂起;
    恢复后继续执行，直到 co_return;
  }
  catch (...) {
    promise.unhandled_exception();
  }

final_suspend:
  co_await promise.final_suspsend();
```

上面描述了 `co_await` 和 `co_return`，那 `co_yield` 呢？也很简单， `co_yield 表达式` 等价于：

```cpp
co_await promise.yield_value(表达式);
```



> 《现代C++ 编程实战》
> https://en.cppreference.com/w/cpp/language/coroutines.html
> https://blog.panicsoftware.com/coroutines-introduction/
> https://blog.panicsoftware.com/your-first-coroutine/