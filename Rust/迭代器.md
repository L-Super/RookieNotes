**迭代器**（*iterator*）负责遍历序列中的每一项并确定序列何时结束的逻辑。

先创建迭代器，然后使用 `for` 循环：

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!("Got: {val}");
}
```

## Iterator trait 和 next 方法

所有迭代器都实现了标准库中定义的 `Iterator` 的 trait。

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // 此处省略了方法的默认实现
}
```

`Iterator` trait 仅要求实现者定义一个方法：`next` 方法，该方法每次返回迭代器中的一个项，封装在 `Some` 中，并且当迭代完成时，返回 `None`。

对由 vector 创建的迭代器重复调用 `next` 方法时返回的值：

```rust
let v1 = vec![1, 2, 3];

let mut v1_iter = v1.iter();

assert_eq!(v1_iter.next(), Some(&1));
assert_eq!(v1_iter.next(), Some(&2));
assert_eq!(v1_iter.next(), Some(&3));
assert_eq!(v1_iter.next(), None);
```

注意，我们需要将 `v1_iter` 声明为可变的：在迭代器上调用 `next` 方法会改变迭代器用于跟踪其在序列中位置的内部状态。换句话说，代码会消费（consume）或用尽迭代器。每次调用 `next` 都会从迭代器中消耗一个元素。使用 `for` 循环时，不需要将 `v1_iter` 设为可变的，因为 `for` 循环会获取 `v1_iter` 的所有权，并在幕后将其设为可变的。

还需要注意的是，从 `next` 调用中获取的值是对 vector 中值的不可变引用。`iter` 方法生成一个不可变引用的迭代器。如果需要获取 `v1` 所有权并返回拥有所有权的迭代器，则可以调用 `into_iter` 而不是 `iter`。类似地，如果希望迭代可变引用，可以调用 `iter_mut` 而不是 `iter`。

## 消费迭代器的方法

调用 `next` 方法的方法被称为**消费适配器**（*consuming adapters*）

调用 `sum` 方法获取迭代器所有项的总和：

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

let total: i32 = v1_iter.sum();

assert_eq!(total, 6);
```

 `sum` 方法获取迭代器的所有权并反复调用 `next` 来遍历迭代器，从而消费迭代器。在遍历过程中，它将每个项累加到一个运行时总和中，并在迭代完成时返回这个总和。

## 产生其他迭代器的方法

`Iterator` trait 中定义了另一类方法，被称为**迭代器适配器**（*iterator adapters*），它们不会消耗当前的迭代器，而是通过改变原始迭代器的某些方面来生成不同的迭代器。

调用迭代器适配器方法 `map` ：

```rust
let v1: Vec<i32> = vec![1, 2, 3];
let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
```

`map` 方法返回一个新的迭代器，该迭代器生成经过修改的元素。这里的闭包创建了一个新的迭代器，其中 vector 中的每个元素都被加 1。接着调用 `collect` 方法消费新迭代器并创建一个 vector

使用 `filter` 方法和捕获 `shoe_size` 的闭包：

```rust
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    // into_iter 创建一个获取 vector 所有权的迭代器
    // filter 将这个迭代器适配成一个只含有那些闭包返回 true 的元素的新迭代器
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

// ...

let shoes = vec![
	Shoe {
		size: 10,
		style: String::from("sneaker"),
	},
	Shoe {
		size: 13,
		style: String::from("sandal"),
	},
	Shoe {
		size: 10,
		style: String::from("boot"),
	},
];

let in_my_size = shoes_in_size(shoes, 10);

assert_eq!(
	in_my_size,
	vec![
		Shoe {
			size: 10,
			style: String::from("sneaker")
		},
		Shoe {
			size: 10,
			style: String::from("boot")
		},
	]
);
```
